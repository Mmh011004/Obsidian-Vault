# 2.1 信息存储
## 2.1.1 关于C语言各种数据类型所占的存储

![[Pasted image 20231127142851.png]]
1. char：字节数：1。字符型的本质就是整型
2. int：字节数：4。整型分为整形常量和整形变量，常量就是我们平时所看到的准确的数字，例如：1、20、333等等，变量则按我的理解是我像内存去申请一个存储空间，告诉内存空间我申请了这个地方用来存放一个整形的数据，但是什么时候放并没有直接确定。一般占4个字节（32位），最高位代表符号，0表示正数，1表示负数，取值是-2147483648~2147483647，在内存中的存储顺序是低位在前、高位在后，例如0x12345678。
3. float：字节数：4.最高位是符号位，紧接着8位是指数位，剩下的23位是尾数位。%f
4. double：字节数：8.最高位是符号位，紧接着8位是指数位，剩下的52位是尾数位。%lf

## 2.1.2 布尔代数
- ~ 非
- & 与
- | 或
- ^ 异或
## 2.1.3 C语言中的位级运算

将C语言中的表达式中的十六进制数字先转化为二进制，在二进制中对这些数字进行**与或非运算**，运算后再将二进制转换为十六进制。

例如：
>~[0100 0001]  => [1011 1110]
>[0110 1001] & [0101 0101] => [0100 0001]

## 2.1.4 逻辑运算

- ||      OR
- &&  AND
- ！    NOT
- 在逻辑运算中的结果只有**True False** . 1为True 0为False
- 非0的参数都为**True**

示例：
>! 0x41  =>  0x00
>! 0x00  =>  0x01
>!! 0x41 =>  0x01
>0x69 && 0x55  =>  0x01     等价     1 && 1 = 1

## 2.1.5 逻辑运算与位运算的区别

- 逻辑运算用于判断真假，非0为真
- 逻辑运算的结果只有**1和0**
- 逻辑运算可以提前终止
- 位运算返回的是一个具体的数值
- 两者的重要区别：**逻辑运算 如果第一个参数可以确定表达式的结果，就不会再求第二个**

## 2.1.6 位移操作

- 左移         x << y            x左移y位，低位补0
- 右移         x >> y            
	- logical shift 逻辑右移：高位补0
	- arithmetic shift 算术右移：**需要看最高位**
		- 最高位为**0**：与逻辑右移一致
		- 最高位为**1**：高位补1
	- C 没有明确给出使用哪一种右移。无符号——逻辑，有符号——算术右移，补符号位的数。
- 若位移量k超过了位数w
	- 计算位移量：k mod w

## 2.1.7 位扩展

**也就是向高位进行扩展**
- 无符号 向高位填0
- 有符号
	- 向高位填写最高位的数
	- 当是负数的时候进行理解
		- 例
		 > [1001]  =>  [11001]
		- 扩展前和扩展后：次高位的数从-8变成8，差值为16，所以是增大了16.最高位为1是-16

## 2.1.8 截断数字

- 无符号
	- $x′=x\text { mod }2^k$ 
	- 原理：每一个权在取模的操作下结果都是0
- 补码
	- $x^′ = \text{U2}T_k(x \text{ mod }2^k)$ 

## 2.1.9 强制转换

> 只是改变了解释这些位的方式

# 2.2 整数运算
## 2.2.1 

